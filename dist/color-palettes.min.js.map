{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///color-palettes.min.js","webpack:///webpack/bootstrap b161b04b5161bc0fe032","webpack:///./index.js","webpack:///./MMCQ/index.js","webpack:///./MMCQ/pv.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_MMCQ","_MMCQ2","componentToHex","hex","toString","rgbToHex","rgb","ColorPalettes","image","_this","HTMLImageElement","_image","fetching","Promise","resolve","_imageUrl","reject","_fetchImage","Image","crossOrigin","src","onload","_getCanvas","getContext","getImageData","width","height","data","_canvas","context","document","createElement","drawImage","_ref","arguments","undefined","_ref$format","format","getPalette","colorCount","then","res","slice","_this2","_ref2","_ref2$colorCount","_ref2$format","r","g","b","pixels","_getPixelArray","pixelCount","pixelArray","push","cmap","palettes","palette","hexPalettes","map","_pv","_pv2","sigbits","rshift","maxIterations","fractByPopulations","getColorIndex","PQueue","comparator","contents","sorted","sort","o","peek","index","pop","size","f","debug","getHisto","histosize","histo","Array","rval","gval","bval","forEach","pixel","vboxFromPixels","rmin","rmax","gmin","gmax","bmin","bmax","VBox","medianCutApply","vbox","doCut","color","dim1","dim2","left","right","vbox1","vbox2","d2","count2","partialsum","total","copy","Math","min","max","lookaheadsum","count","rw","r2","r1","gw","g2","g1","bw","b2","b1","maxw","apply","j","k","sum","d","quantize","maxcolors","iter","lh","ncolors","niters","vboxes","console","log","nColors","pq","a","naturalOrder","pq2","volume","CMap","force","_volume","_count_set","npix","_count","_avg","ntot","mult","rsum","gsum","bsum","hval","histoindex","avg","vb","contains","nearest","d1","pColor","sqrt","pow","lowest","idx","highest","array","reduce"],"mappings":"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","file":"color-palettes.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ColorPalettes\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ColorPalettes\"] = factory();\n\telse\n\t\troot[\"ColorPalettes\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ColorPalettes\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ColorPalettes\"] = factory();\n\telse\n\t\troot[\"ColorPalettes\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _MMCQ = __webpack_require__(1);\n\t\n\tvar _MMCQ2 = _interopRequireDefault(_MMCQ);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar componentToHex = function componentToHex(c) {\n\t  var hex = c.toString(16);\n\t  return hex.length == 1 ? '0' + hex : hex;\n\t};\n\t\n\tvar rgbToHex = function rgbToHex(rgb) {\n\t  var c = '';\n\t  for (var i = 0; i < 3; i++) {\n\t    c += componentToHex(rgb[i]);\n\t  }\n\t  return c;\n\t};\n\t\n\tvar ColorPalettes = function () {\n\t  function ColorPalettes(image) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, ColorPalettes);\n\t\n\t    if (image instanceof HTMLImageElement) {\n\t      this._image = image;\n\t      this.fetching = new Promise(function (resolve) {\n\t        resolve();\n\t      });\n\t    } else if (typeof image === 'string') {\n\t      this._imageUrl = image;\n\t      this.fetching = new Promise(function (resolve, reject) {\n\t        _this._fetchImage(resolve, reject);\n\t      });\n\t    }\n\t  }\n\t\n\t  _createClass(ColorPalettes, [{\n\t    key: '_fetchImage',\n\t    value: function _fetchImage(resolve, reject) {\n\t      this._image = new Image();\n\t      this._image.crossOrigin = 'anonymous';\n\t      this._image.src = this._imageUrl;\n\t      this._image.onload = function () {\n\t        resolve();\n\t      };\n\t    }\n\t  }, {\n\t    key: '_getPixelArray',\n\t    value: function _getPixelArray() {\n\t      return this._getCanvas().getContext('2d').getImageData(0, 0, this._image.width, this._image.height).data;\n\t    }\n\t  }, {\n\t    key: '_getCanvas',\n\t    value: function _getCanvas() {\n\t      if (this._canvas) {\n\t        return this._canvas;\n\t      }\n\t\n\t      var canvas = void 0,\n\t          context = void 0;\n\t\n\t      this._canvas = document.createElement('canvas');\n\t      this._canvas.width = this._image.width;\n\t      this._canvas.height = this._image.height;\n\t      context = this._canvas.getContext('2d');\n\t\n\t      context.drawImage(this._image, 0, 0);\n\t\n\t      return this._canvas;\n\t    }\n\t  }, {\n\t    key: 'dominantThree',\n\t    value: function dominantThree() {\n\t      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _ref$format = _ref.format;\n\t      var format = _ref$format === undefined ? 'rgb' : _ref$format;\n\t\n\t\n\t      return this.getPalette({\n\t        colorCount: 5,\n\t        format: format\n\t      }).then(function (res) {\n\t        return res.slice(0, 3);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'getPalette',\n\t    value: function getPalette() {\n\t      var _this2 = this;\n\t\n\t      var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _ref2$colorCount = _ref2.colorCount;\n\t      var colorCount = _ref2$colorCount === undefined ? 10 : _ref2$colorCount;\n\t      var _ref2$format = _ref2.format;\n\t      var format = _ref2$format === undefined ? 'rgb' : _ref2$format;\n\t\n\t\n\t      return this.fetching.then(function (res) {\n\t        var pixels = _this2._getPixelArray();\n\t        var pixelCount = _this2._image.width * _this2._image.height;\n\t\n\t        var pixelArray = [];\n\t        for (var i = 0, offset, r, g, b; i < pixelCount; i += 4) {\n\t          r = pixels[i + 0];\n\t          g = pixels[i + 1];\n\t          b = pixels[i + 2];\n\t          pixelArray.push([r, g, b]);\n\t        }\n\t\n\t        var cmap = (0, _MMCQ2.default)(pixelArray, colorCount);\n\t        var palettes = cmap.palette();\n\t        if (format === 'hex') {\n\t          var hexPalettes = palettes.map(function (p) {\n\t            return rgbToHex(p);\n\t          });\n\t          return hexPalettes;\n\t        } else {\n\t          return palettes;\n\t        }\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return ColorPalettes;\n\t}();\n\t\n\texports.default = ColorPalettes;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Rewritten from quantize.js Copyright 2008 Nick Rabinowitz. (http://gist.github.com/1104622) and two bugs fixed in issues\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Basic Javascript port of the MMCQ (modified median cut quantization)\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * algorithm from the Leptonica library (http://www.leptonica.com/).\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Returns a color map you can use to map original pixels to the reduced\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * palette. Still a work in progress.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Nick Rabinowitz\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\t\n\tvar _pv = __webpack_require__(2);\n\t\n\tvar _pv2 = _interopRequireDefault(_pv);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// private constants\n\tvar sigbits = 5;\n\tvar rshift = 8 - sigbits;\n\tvar maxIterations = 1000;\n\tvar fractByPopulations = 0.75;\n\t\n\t// get reduced-space color index for a pixel\n\tvar getColorIndex = function getColorIndex(r, g, b) {\n\t  return (r << 2 * sigbits) + (g << sigbits) + b;\n\t};\n\t\n\t// Simple priority queue\n\tvar PQueue = function PQueue(comparator) {\n\t  var contents = [],\n\t      sorted = false;\n\t\n\t  var sort = function sort() {\n\t    contents.sort(comparator);\n\t    sorted = true;\n\t  };\n\t\n\t  return {\n\t    push: function push(o) {\n\t      contents.push(o);\n\t      sorted = false;\n\t    },\n\t    peek: function peek(index) {\n\t      if (!sorted) sort();\n\t      if (index === undefined) index = contents.length - 1;\n\t      return contents[index];\n\t    },\n\t    pop: function pop() {\n\t      if (!sorted) sort();\n\t      return contents.pop();\n\t    },\n\t    size: function size() {\n\t      return contents.length;\n\t    },\n\t    map: function map(f) {\n\t      return contents.map(f);\n\t    },\n\t    debug: function debug() {\n\t      if (!sorted) sort();\n\t      return contents;\n\t    }\n\t  };\n\t};\n\t\n\t// histo (1-d array, giving the number of pixels in\n\t// each quantized region of color space), or null on error\n\tvar getHisto = function getHisto(pixels) {\n\t  var histosize = 1 << 3 * sigbits,\n\t      histo = new Array(histosize),\n\t      index = void 0,\n\t      rval = void 0,\n\t      gval = void 0,\n\t      bval = void 0;\n\t  pixels.forEach(function (pixel) {\n\t    rval = pixel[0] >> rshift;\n\t    gval = pixel[1] >> rshift;\n\t    bval = pixel[2] >> rshift;\n\t    index = getColorIndex(rval, gval, bval);\n\t    histo[index] = (histo[index] || 0) + 1;\n\t  });\n\t  return histo;\n\t};\n\t\n\tvar vboxFromPixels = function vboxFromPixels(pixels, histo) {\n\t  var rmin = 1000000,\n\t      rmax = 0,\n\t      gmin = 1000000,\n\t      gmax = 0,\n\t      bmin = 1000000,\n\t      bmax = 0,\n\t      rval = void 0,\n\t      gval = void 0,\n\t      bval = void 0;\n\t  // find min/max\n\t  pixels.forEach(function (pixel) {\n\t    rval = pixel[0] >> rshift;\n\t    gval = pixel[1] >> rshift;\n\t    bval = pixel[2] >> rshift;\n\t    if (rval < rmin) rmin = rval;else if (rval > rmax) rmax = rval;\n\t    if (gval < gmin) gmin = gval;else if (gval > gmax) gmax = gval;\n\t    if (bval < bmin) bmin = bval;else if (bval > bmax) bmax = bval;\n\t  });\n\t  return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n\t};\n\t\n\tvar medianCutApply = function medianCutApply(histo, vbox) {\n\t  if (!vbox.count()) return;\n\t\n\t  var rw = vbox.r2 - vbox.r1 + 1,\n\t      gw = vbox.g2 - vbox.g1 + 1,\n\t      bw = vbox.b2 - vbox.b1 + 1,\n\t      maxw = Math.max.apply(Math, [rw, gw, bw]);\n\t  // only one pixel, no split\n\t  if (vbox.count() == 1) {\n\t    return [vbox.copy()];\n\t  }\n\t  /* Find the partial sum arrays along the selected axis. */\n\t  var total = 0,\n\t      partialsum = [],\n\t      lookaheadsum = [],\n\t      i = void 0,\n\t      j = void 0,\n\t      k = void 0,\n\t      sum = void 0,\n\t      index = void 0;\n\t  if (maxw == rw) {\n\t    for (i = vbox.r1; i <= vbox.r2; i++) {\n\t      sum = 0;\n\t      for (j = vbox.g1; j <= vbox.g2; j++) {\n\t        for (k = vbox.b1; k <= vbox.b2; k++) {\n\t          index = getColorIndex(i, j, k);\n\t          sum += histo[index] || 0;\n\t        }\n\t      }\n\t      total += sum;\n\t      partialsum[i] = total;\n\t    }\n\t  } else if (maxw == gw) {\n\t    for (i = vbox.g1; i <= vbox.g2; i++) {\n\t      sum = 0;\n\t      for (j = vbox.r1; j <= vbox.r2; j++) {\n\t        for (k = vbox.b1; k <= vbox.b2; k++) {\n\t          index = getColorIndex(j, i, k);\n\t          sum += histo[index] || 0;\n\t        }\n\t      }\n\t      total += sum;\n\t      partialsum[i] = total;\n\t    }\n\t  } else {\n\t    /* maxw == bw */\n\t    for (i = vbox.b1; i <= vbox.b2; i++) {\n\t      sum = 0;\n\t      for (j = vbox.r1; j <= vbox.r2; j++) {\n\t        for (k = vbox.g1; k <= vbox.g2; k++) {\n\t          index = getColorIndex(j, k, i);\n\t          sum += histo[index] || 0;\n\t        }\n\t      }\n\t      total += sum;\n\t      partialsum[i] = total;\n\t    }\n\t  }\n\t  partialsum.forEach(function (d, i) {\n\t    lookaheadsum[i] = total - d;\n\t  });\n\t  function doCut(color) {\n\t    var dim1 = color + '1',\n\t        dim2 = color + '2',\n\t        left = void 0,\n\t        right = void 0,\n\t        vbox1 = void 0,\n\t        vbox2 = void 0,\n\t        d2 = void 0,\n\t        count2 = 0;\n\t    for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n\t      if (partialsum[i] > total / 2) {\n\t        vbox1 = vbox.copy();\n\t        vbox2 = vbox.copy();\n\t        left = i - vbox[dim1];\n\t        right = vbox[dim2] - i;\n\t        if (left <= right) d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n\t        // avoid 0-count boxes\n\t        while (!partialsum[d2]) {\n\t          d2++;\n\t        }count2 = lookaheadsum[d2];\n\t        while (!count2 && partialsum[d2 - 1]) {\n\t          count2 = lookaheadsum[--d2];\n\t        } // set dimensions\n\t        vbox1[dim2] = d2;\n\t        vbox2[dim1] = vbox1[dim2] + 1;\n\t        // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n\t        return [vbox1, vbox2];\n\t      }\n\t    }\n\t  }\n\t  // determine the cut planes\n\t  return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');\n\t};\n\t\n\tvar quantize = function quantize(pixels, maxcolors) {\n\t  // short-circuit\n\t  if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n\t    console.log('wrong number of maxcolors');\n\t    return false;\n\t  }\n\t\n\t  // XXX: check color content and convert to grayscale if insufficient\n\t\n\t  var histo = getHisto(pixels),\n\t      histosize = 1 << 3 * sigbits;\n\t\n\t  // check that we aren't below maxcolors already\n\t  var nColors = 0;\n\t  histo.forEach(function () {\n\t    nColors++;\n\t  });\n\t  if (nColors <= maxcolors) {}\n\t  // XXX: generate the new colors from the histo and return\n\t\n\t\n\t  // get the beginning vbox from the colors\n\t  var vbox = vboxFromPixels(pixels, histo),\n\t      pq = new PQueue(function (a, b) {\n\t    return _pv2.default.naturalOrder(a.count(), b.count());\n\t  });\n\t  pq.push(vbox);\n\t\n\t  // inner function to do the iteration\n\t  function iter(lh, target) {\n\t    var ncolors = 1,\n\t        niters = 0,\n\t        vbox = void 0;\n\t    while (niters < maxIterations) {\n\t      vbox = lh.pop();\n\t      if (!vbox.count()) {\n\t        /* just put it back */\n\t        lh.push(vbox);\n\t        niters++;\n\t        continue;\n\t      }\n\t      // do the cut\n\t      var vboxes = medianCutApply(histo, vbox),\n\t          vbox1 = vboxes[0],\n\t          vbox2 = vboxes[1];\n\t\n\t      if (!vbox1) {\n\t        console.log(\"vbox1 not defined; shouldn't happen!\");\n\t        return;\n\t      }\n\t      lh.push(vbox1);\n\t      if (vbox2) {\n\t        /* vbox2 can be null */\n\t        lh.push(vbox2);\n\t        ncolors++;\n\t      }\n\t      if (ncolors >= target) return;\n\t      if (niters++ > maxIterations) {\n\t        console.log(\"infinite loop; perhaps too few pixels!\");\n\t        return;\n\t      }\n\t    }\n\t  }\n\t\n\t  // first set of colors, sorted by population\n\t  iter(pq, fractByPopulations * maxcolors);\n\t  // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\t\n\t  // Re-sort by the product of pixel occupancy times the size in color space.\n\t  var pq2 = new PQueue(function (a, b) {\n\t    return _pv2.default.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n\t  });\n\t  while (pq.size()) {\n\t    pq2.push(pq.pop());\n\t  }\n\t\n\t  // next set - generate the median cuts using the (npix * vol) sorting.\n\t  iter(pq2, maxcolors - pq2.size());\n\t\n\t  // calculate the actual colors\n\t  var cmap = new CMap();\n\t  while (pq2.size()) {\n\t    cmap.push(pq2.pop());\n\t  }\n\t\n\t  return cmap;\n\t};\n\t\n\t// 3d color space box\n\t\n\tvar VBox = function () {\n\t  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n\t    _classCallCheck(this, VBox);\n\t\n\t    this.r1 = r1;\n\t    this.r2 = r2;\n\t    this.g1 = g1;\n\t    this.g2 = g2;\n\t    this.b1 = b1;\n\t    this.b2 = b2;\n\t    this.histo = histo;\n\t  }\n\t\n\t  _createClass(VBox, [{\n\t    key: 'volume',\n\t    value: function volume(force) {\n\t      if (!this._volume || force) {\n\t        this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);\n\t      }\n\t      return this._volume;\n\t    }\n\t  }, {\n\t    key: 'count',\n\t    value: function count(force) {\n\t      var histo = this.histo;\n\t      if (!this._count_set || force) {\n\t        var npix = 0,\n\t            i = void 0,\n\t            j = void 0,\n\t            k = void 0;\n\t        for (i = this.r1; i <= this.r2; i++) {\n\t          for (j = this.g1; j <= this.g2; j++) {\n\t            for (k = this.b1; k <= this.b2; k++) {\n\t              var index = getColorIndex(i, j, k);\n\t              npix += histo[index] || 0;\n\t            }\n\t          }\n\t        }\n\t        this._count = npix;\n\t        this._count_set = true;\n\t      }\n\t      return this._count;\n\t    }\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy() {\n\t      return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.histo);\n\t    }\n\t  }, {\n\t    key: 'avg',\n\t    value: function avg(force) {\n\t      var histo = this.histo;\n\t      if (!this._avg || force) {\n\t        var ntot = 0,\n\t            mult = 1 << 8 - sigbits,\n\t            rsum = 0,\n\t            gsum = 0,\n\t            bsum = 0,\n\t            hval = void 0,\n\t            i = void 0,\n\t            j = void 0,\n\t            k = void 0,\n\t            histoindex = void 0;\n\t        for (i = this.r1; i <= this.r2; i++) {\n\t          for (j = this.g1; j <= this.g2; j++) {\n\t            for (k = this.b1; k <= this.b2; k++) {\n\t              histoindex = getColorIndex(i, j, k);\n\t              hval = histo[histoindex] || 0;\n\t              ntot += hval;\n\t              rsum += hval * (i + 0.5) * mult;\n\t              gsum += hval * (j + 0.5) * mult;\n\t              bsum += hval * (k + 0.5) * mult;\n\t            }\n\t          }\n\t        }\n\t        if (ntot) {\n\t          this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n\t        } else {\n\t          console.log('empty box');\n\t          this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];\n\t        }\n\t      }\n\t      return this._avg;\n\t    }\n\t  }, {\n\t    key: 'contains',\n\t    value: function contains(pixel) {\n\t      var rval = pixel[0] >> rshift,\n\t          gval = pixel[1] >> rshift,\n\t          bval = pixel[2] >> rshift;\n\t      return rval >= this.r1 && rval <= this.r2 && gval >= this.g1 && gval <= this.g2 && bval >= this.b1 && bval <= this.b2;\n\t    }\n\t  }]);\n\t\n\t  return VBox;\n\t}();\n\t\n\t// Color map\n\t\n\t\n\tvar CMap = function () {\n\t  function CMap() {\n\t    _classCallCheck(this, CMap);\n\t\n\t    this.vboxes = new PQueue(function (a, b) {\n\t      return _pv2.default.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\n\t    });\n\t  }\n\t\n\t  _createClass(CMap, [{\n\t    key: 'push',\n\t    value: function push(vbox) {\n\t      this.vboxes.push({\n\t        vbox: vbox,\n\t        color: vbox.avg()\n\t      });\n\t    }\n\t  }, {\n\t    key: 'palette',\n\t    value: function palette() {\n\t      return this.vboxes.map(function (vb) {\n\t        return vb.color;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'size',\n\t    value: function size() {\n\t      return this.vboxes.size();\n\t    }\n\t  }, {\n\t    key: 'map',\n\t    value: function map(color) {\n\t      var vboxes = this.vboxes;\n\t      for (var i = 0; i < vboxes.size(); i++) {\n\t        if (vboxes.peek(i).vbox.contains(color)) {\n\t          return vboxes.peek(i).color;\n\t        }\n\t      }\n\t      return this.nearest(color);\n\t    }\n\t  }, {\n\t    key: 'nearest',\n\t    value: function nearest(color) {\n\t      var vboxes = this.vboxes,\n\t          d1 = void 0,\n\t          d2 = void 0,\n\t          pColor = void 0;\n\t      for (var i = 0; i < vboxes.size(); i++) {\n\t        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\n\t        if (d2 < d1 || d1 === undefined) {\n\t          d1 = d2;\n\t          pColor = vboxes.peek(i).color;\n\t        }\n\t      }\n\t      return pColor;\n\t    }\n\t  }, {\n\t    key: 'forcebw',\n\t    value: function forcebw() {\n\t      // XXX: won't  work yet\n\t      var vboxes = this.vboxes;\n\t      vboxes.sort(function (a, b) {\n\t        return _pv2.default.naturalOrder(_pv2.default.sum(a.color), _pv2.default.sum(b.color));\n\t      });\n\t\n\t      // force darkest color to black if everything < 5\n\t      var lowest = vboxes[0].color;\n\t      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) vboxes[0].color = [0, 0, 0];\n\t\n\t      // force lightest color to white if everything > 251\n\t      var idx = vboxes.length - 1,\n\t          highest = vboxes[idx].color;\n\t      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) vboxes[idx].color = [255, 255, 255];\n\t    }\n\t  }]);\n\t\n\t  return CMap;\n\t}();\n\t\n\texports.default = quantize;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// fill out a couple protovis dependencies\n\t/*!\n\t * Block below copied from Protovis: http://mbostock.github.com/protovis/\n\t * Copyright 2010 Stanford Visualization Group\n\t * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n\t */\n\texports.default = {\n\t  map: function map(array, f) {\n\t    var o = {};\n\t    return f ? array.map(function (d, i) {\n\t      o.index = i;return f.call(o, d);\n\t    }) : array.slice();\n\t  },\n\t  naturalOrder: function naturalOrder(a, b) {\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t  },\n\t  sum: function sum(array, f) {\n\t    var o = {};\n\t    return array.reduce(f ? function (p, d, i) {\n\t      o.index = i;return p + f.call(o, d);\n\t    } : function (p, d) {\n\t      return p + d;\n\t    }, 0);\n\t  }\n\t};\n\tmodule.exports = exports[\"default\"];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** color-palettes.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b161b04b5161bc0fe032\n **/","import quantize from './MMCQ'\n\nconst componentToHex = (c) => {\n  let hex = c.toString(16);\n  return hex.length == 1 ? '0' + hex : hex ;\n}   \n\nconst rgbToHex = (rgb) => {\n  let c = '';\n  for(let i=0; i<3; i++){\n    c += componentToHex(rgb[i]);\n  }   \n  return c;\n}   \n\nexport default class ColorPalettes {\n\n  constructor(image) {\n    if(image instanceof HTMLImageElement) {\n      this._image = image;\n      this.fetching = new Promise( (resolve) => {\n        resolve();\n      })\n    }\n    else if (typeof image === 'string'){\n      this._imageUrl = image;\n      this.fetching = new Promise( (resolve, reject) => {\n        this._fetchImage(resolve, reject);\n      })\n    }\n  }\n\n  _fetchImage (resolve, reject) {\n    this._image = new Image();\n    this._image.crossOrigin = 'anonymous'; \n    this._image.src = this._imageUrl;\n    this._image.onload = () => {\n      resolve();\n    }\n  }\n\n  _getPixelArray () {\n\t\treturn this._getCanvas().getContext('2d').getImageData(0, 0, this._image.width, this._image.height).data;\n  }\n\n  _getCanvas () {\n    if (this._canvas) {\n\t\t\treturn this._canvas;\n\t\t}\n\n\t\tlet canvas, context;\n\n\t\tthis._canvas = document.createElement('canvas');\n\t\tthis._canvas.width = this._image.width;\n\t\tthis._canvas.height = this._image.height;\n\t\tcontext = this._canvas.getContext('2d');\n\n\t\tcontext.drawImage(this._image, 0, 0);\n\n\t\treturn this._canvas;\n  }\n\n  dominantThree ({format = 'rgb'} = {}){\n\n    return this.getPalette({\n      colorCount: 5,\n      format: format\n    }).then( (res) => {\n      return res.slice(0,3);\n    });\n  }\n\n  getPalette ({colorCount = 10, format = 'rgb'} = {}) {\n\n    return this.fetching.then( (res) => {\n      let pixels = this._getPixelArray();\n      let pixelCount = this._image.width * this._image.height;\n\n      let pixelArray = [];\n      for(let i=0, offset, r, g, b; i<pixelCount; i+=4) {\n        r = pixels[i + 0];\n        g = pixels[i + 1];\n        b = pixels[i + 2];\n        pixelArray.push([r, g, b]);\n      }\n\n      let cmap = quantize(pixelArray, colorCount);\n      let palettes = cmap.palette();\n      if(format === 'hex'){\n        let hexPalettes = palettes.map( (p) => {\n          return rgbToHex(p);\n        });\n        return hexPalettes;\n      }\n      else{\n        return palettes;\n      }\n    });\n  }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","/**\n * Rewritten from quantize.js Copyright 2008 Nick Rabinowitz. (http://gist.github.com/1104622) and two bugs fixed in issues\n *\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n *\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n *\n * @author Nick Rabinowitz\n */\nimport pv from './pv'\n\n// private constants\nconst sigbits = 5;\nconst rshift = 8 - sigbits;\nconst maxIterations = 1000;\nconst fractByPopulations = 0.75;\n\n// get reduced-space color index for a pixel\nconst getColorIndex = (r, g, b) => {\n  return (r << (2 * sigbits)) + (g << sigbits) + b;\n}\n\n// Simple priority queue\nconst PQueue = (comparator) => {\n  let contents = [],\n    sorted = false;\n\n  let sort = () => {\n    contents.sort(comparator);\n    sorted = true;\n  }\n\n  return {\n    push: function(o) {\n      contents.push(o);\n      sorted = false;\n    },\n    peek: function(index) {\n      if (!sorted) sort();\n      if (index===undefined) index = contents.length - 1;\n      return contents[index];\n    },\n    pop: function() {\n      if (!sorted) sort();\n      return contents.pop();\n    },\n    size: function() {\n      return contents.length;\n    },\n    map: function(f) {\n      return contents.map(f);\n    },\n    debug: function() {\n      if (!sorted) sort();\n      return contents;\n    }\n  };\n}\n\n// histo (1-d array, giving the number of pixels in\n// each quantized region of color space), or null on error\nconst getHisto = (pixels) => {\n  let histosize = 1 << (3 * sigbits),\n    histo = new Array(histosize),\n    index, rval, gval, bval;\n  pixels.forEach(function(pixel) {\n    rval = pixel[0] >> rshift;\n    gval = pixel[1] >> rshift;\n    bval = pixel[2] >> rshift;\n    index = getColorIndex(rval, gval, bval);\n    histo[index] = (histo[index] || 0) + 1;\n  });\n  return histo;\n}\n\nconst vboxFromPixels = (pixels, histo) => {\n  let rmin=1000000, rmax=0,\n    gmin=1000000, gmax=0,\n    bmin=1000000, bmax=0,\n    rval, gval, bval;\n  // find min/max\n  pixels.forEach(function(pixel) {\n    rval = pixel[0] >> rshift;\n    gval = pixel[1] >> rshift;\n    bval = pixel[2] >> rshift;\n    if (rval < rmin) rmin = rval;\n    else if (rval > rmax) rmax = rval;\n    if (gval < gmin) gmin = gval;\n    else if (gval > gmax) gmax = gval;\n    if (bval < bmin) bmin = bval;\n    else if (bval > bmax)  bmax = bval;\n  });\n  return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n}\n\nconst medianCutApply = (histo, vbox) => {\n  if (!vbox.count()) return;\n\n  let rw = vbox.r2 - vbox.r1 + 1,\n    gw = vbox.g2 - vbox.g1 + 1,\n    bw = vbox.b2 - vbox.b1 + 1,\n    maxw = Math.max(...[rw, gw, bw]);\n  // only one pixel, no split\n  if (vbox.count() == 1) {\n    return [vbox.copy()]\n  }\n  /* Find the partial sum arrays along the selected axis. */\n  let total = 0,\n    partialsum = [],\n    lookaheadsum = [],\n    i, j, k, sum, index;\n  if (maxw == rw) {\n    for (i = vbox.r1; i <= vbox.r2; i++) {\n      sum = 0;\n      for (j = vbox.g1; j <= vbox.g2; j++) {\n        for (k = vbox.b1; k <= vbox.b2; k++) {\n          index = getColorIndex(i,j,k);\n          sum += (histo[index] || 0);\n        }\n      }\n      total += sum;\n      partialsum[i] = total;\n    }\n  }\n  else if (maxw == gw) {\n    for (i = vbox.g1; i <= vbox.g2; i++) {\n      sum = 0;\n      for (j = vbox.r1; j <= vbox.r2; j++) {\n        for (k = vbox.b1; k <= vbox.b2; k++) {\n          index = getColorIndex(j,i,k);\n          sum += (histo[index] || 0);\n        }\n      }\n      total += sum;\n      partialsum[i] = total;\n    }\n  }\n  else {  /* maxw == bw */\n    for (i = vbox.b1; i <= vbox.b2; i++) {\n      sum = 0;\n      for (j = vbox.r1; j <= vbox.r2; j++) {\n        for (k = vbox.g1; k <= vbox.g2; k++) {\n          index = getColorIndex(j,k,i);\n          sum += (histo[index] || 0);\n        }\n      }\n      total += sum;\n      partialsum[i] = total;\n    }\n  }\n  partialsum.forEach(function(d,i) {\n    lookaheadsum[i] = total-d;\n  });\n  function doCut(color) {\n    let dim1 = color + '1',\n      dim2 = color + '2',\n      left, right, vbox1, vbox2, d2, count2=0;\n    for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n      if (partialsum[i] > total / 2) {\n        vbox1 = vbox.copy();\n        vbox2 = vbox.copy();\n        left = i - vbox[dim1];\n        right = vbox[dim2] - i;\n        if (left <= right)\n            d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));\n        else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n        // avoid 0-count boxes\n        while (!partialsum[d2]) d2++;\n        count2 = lookaheadsum[d2];\n        while (!count2 && partialsum[d2-1]) count2 = lookaheadsum[--d2];\n        // set dimensions\n        vbox1[dim2] = d2;\n        vbox2[dim1] = vbox1[dim2] + 1;\n        // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n        return [vbox1, vbox2];\n      }\n    }\n  }\n  // determine the cut planes\n  return maxw == rw ? doCut('r') :\n    maxw == gw ? doCut('g') :\n    doCut('b');\n}\n\nconst quantize = (pixels, maxcolors) => {\n  // short-circuit\n  if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n    console.log('wrong number of maxcolors');\n    return false;\n  }\n\n  // XXX: check color content and convert to grayscale if insufficient\n\n  let histo = getHisto(pixels),\n    histosize = 1 << (3 * sigbits);\n\n  // check that we aren't below maxcolors already\n  let nColors = 0;\n  histo.forEach(function() { nColors++ });\n  if (nColors <= maxcolors) {\n    // XXX: generate the new colors from the histo and return\n  }\n\n  // get the beginning vbox from the colors\n  let vbox = vboxFromPixels(pixels, histo),\n    pq = new PQueue(function(a,b) { return pv.naturalOrder(a.count(), b.count()) });\n  pq.push(vbox);\n\n  // inner function to do the iteration\n  function iter(lh, target) {\n    let ncolors = 1,\n      niters = 0,\n      vbox;\n    while (niters < maxIterations) {\n      vbox = lh.pop();\n      if (!vbox.count())  { /* just put it back */\n        lh.push(vbox);\n        niters++;\n        continue;\n      }\n      // do the cut\n      let vboxes = medianCutApply(histo, vbox),\n        vbox1 = vboxes[0],\n        vbox2 = vboxes[1];\n\n      if (!vbox1) {\n        console.log(\"vbox1 not defined; shouldn't happen!\");\n        return;\n      }\n      lh.push(vbox1);\n      if (vbox2) {  /* vbox2 can be null */\n        lh.push(vbox2);\n        ncolors++;\n      }\n      if (ncolors >= target) return;\n      if (niters++ > maxIterations) {\n        console.log(\"infinite loop; perhaps too few pixels!\");\n        return;\n      }\n    }\n  }\n\n  // first set of colors, sorted by population\n  iter(pq, fractByPopulations * maxcolors);\n  // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n  // Re-sort by the product of pixel occupancy times the size in color space.\n  let pq2 = new PQueue(function(a,b) {\n    return pv.naturalOrder(a.count()*a.volume(), b.count()*b.volume())\n  });\n  while (pq.size()) {\n    pq2.push(pq.pop());\n  }\n\n  // next set - generate the median cuts using the (npix * vol) sorting.\n  iter(pq2, maxcolors - pq2.size());\n\n  // calculate the actual colors\n  let cmap = new CMap();\n  while (pq2.size()) {\n    cmap.push(pq2.pop());\n  }\n\n  return cmap;\n}\n\n// 3d color space box\nclass VBox {\n  constructor(r1, r2, g1, g2, b1, b2, histo) {\n    this.r1 = r1;\n    this.r2 = r2;\n    this.g1 = g1;\n    this.g2 = g2;\n    this.b1 = b1;\n    this.b2 = b2;\n    this.histo = histo;\n  }\n\n  volume(force) {\n    if (!this._volume || force) {\n        this._volume = ((this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1));\n    }\n    return this._volume;\n  }\n\n  count(force) {\n    let histo = this.histo;\n    if (!this._count_set || force) {\n      let npix = 0,\n        i, j, k;\n      for (i = this.r1; i <= this.r2; i++) {\n        for (j = this.g1; j <= this.g2; j++) {\n          for (k = this.b1; k <= this.b2; k++) {\n            let index = getColorIndex(i,j,k);\n            npix += (histo[index] || 0);\n          }\n        }\n      }\n      this._count = npix;\n      this._count_set = true;\n    }\n    return this._count;\n  }\n\n  copy() {\n    return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.histo);\n  }\n\n  avg(force) {\n    let histo = this.histo;\n    if (!this._avg || force) {\n      let ntot = 0,\n        mult = 1 << (8 - sigbits),\n        rsum = 0,\n        gsum = 0,\n        bsum = 0,\n        hval,\n        i, j, k, histoindex;\n      for (i = this.r1; i <= this.r2; i++) {\n        for (j = this.g1; j <= this.g2; j++) {\n          for (k = this.b1; k <= this.b2; k++) {\n            histoindex = getColorIndex(i,j,k);\n            hval = histo[histoindex] || 0;\n            ntot += hval;\n            rsum += (hval * (i + 0.5) * mult);\n            gsum += (hval * (j + 0.5) * mult);\n            bsum += (hval * (k + 0.5) * mult);\n          }\n        }\n      }\n      if (ntot) {\n        this._avg = [~~(rsum/ntot), ~~(gsum/ntot), ~~(bsum/ntot)];\n      } else {\n        console.log('empty box');\n        this._avg = [\n          ~~(mult * (this.r1 + this.r2 + 1) / 2),\n          ~~(mult * (this.g1 + this.g2 + 1) / 2),\n          ~~(mult * (this.b1 + this.b2 + 1) / 2)\n        ];\n      }\n    }\n    return this._avg;\n  }\n\n  contains(pixel) {\n    let rval = pixel[0] >> rshift,\n      gval = pixel[1] >> rshift,\n      bval = pixel[2] >> rshift;\n    return (rval >= this.r1 && rval <= this.r2 &&\n      gval >= this.g1 && gval <= this.g2 &&\n      bval >= this.b1 && bval <= this.b2);\n  }\n}\n\n// Color map\nclass CMap {\n  constructor() {\n    this.vboxes = new PQueue(function(a,b) {\n      return pv.naturalOrder(\n        a.vbox.count()*a.vbox.volume(),\n        b.vbox.count()*b.vbox.volume()\n      )\n    });\n  }\n\n  push(vbox) {\n    this.vboxes.push({\n      vbox: vbox,\n      color: vbox.avg()\n    });\n  }\n\n  palette() {\n    return this.vboxes.map(function(vb) { return vb.color });\n  }\n\n  size() {\n    return this.vboxes.size();\n  }\n\n  map(color) {\n    let vboxes = this.vboxes;\n    for (let i=0; i<vboxes.size(); i++) {\n      if (vboxes.peek(i).vbox.contains(color)) {\n        return vboxes.peek(i).color;\n      }\n    }\n    return this.nearest(color);\n  }\n\n  nearest(color) {\n    let vboxes = this.vboxes,\n      d1, d2, pColor;\n    for (let i=0; i<vboxes.size(); i++) {\n      d2 = Math.sqrt(\n        Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n        Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n        Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n      );\n      if (d2 < d1 || d1 === undefined) {\n        d1 = d2;\n        pColor = vboxes.peek(i).color;\n      }\n    }\n    return pColor;\n  }\n\n  forcebw() {\n    // XXX: won't  work yet\n    let vboxes = this.vboxes;\n    vboxes.sort(function(a,b) { return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color) )});\n\n    // force darkest color to black if everything < 5\n    let lowest = vboxes[0].color;\n    if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n      vboxes[0].color = [0,0,0];\n\n    // force lightest color to white if everything > 251\n    let idx = vboxes.length-1,\n      highest = vboxes[idx].color;\n    if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n      vboxes[idx].color = [255,255,255];\n  }\n}\n\nexport default quantize;\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./MMCQ/index.js\n **/","// fill out a couple protovis dependencies\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nexport default {\n  map: function(array, f) {\n    let o = {};\n    return f\n      ? array.map(function(d, i) { o.index = i; return f.call(o, d); })\n      : array.slice();\n  },\n  naturalOrder: function(a, b) {\n    return (a < b) ? -1 : ((a > b) ? 1 : 0);\n  },\n  sum: function(array, f) {\n    let o = {};\n    return array.reduce(f\n      ? function(p, d, i) { o.index = i; return p + f.call(o, d); }\n      : function(p, d) { return p + d; }, 0);\n  }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./MMCQ/pv.js\n **/"],"sourceRoot":""}